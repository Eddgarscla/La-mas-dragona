<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Episodio - La M√°s Draga</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      font-family: 'Arial', sans-serif;
      min-height: 100vh;
      background-image: url('WhatsApp Image 2025-12-01 at 07.24.11.jpeg');
      background-repeat: no-repeat;
      background-size: cover;
      background-position: center top;
      color: white;
      overflow-x: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
    }
   @keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(6px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.challengeText {
  text-align: center;
  margin: 4px 0;
  opacity: 0;
  animation: fadeInUp 0.4s ease-out forwards;
}

.challengeName {
  font-size: 1.2rem;
  font-weight: 600;
}

    .sim-panel {
      max-width: 430px;
      margin: 0 auto; /* ya no necesitamos espacio arriba */
      padding: 18px 18px 24px;
      background: rgba(0, 0, 0, 0.40);
      border-radius: 26px;
      backdrop-filter: blur(18px);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.75);
    }

    h1 {
      margin: 0 0 8px;
      font-size: 2.0rem;
      text-align: center;
      line-height: 1.2;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      background: linear-gradient(90deg, #ffd700, #ff69b4, #7b5dff);
      -webkit-background-clip: text;
      color: transparent;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.9);
    }

    #episodeSubtitle {
      margin: 0 0 14px;
      text-align: center;
      font-size: 0.95rem;
      opacity: 0.9;
    }

    h2.sectionTitle {
      margin: 14px 0 8px;
      font-size: 1.15rem;
      text-align: left;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      text-shadow:
        0 0 8px rgba(0,0,0,0.9),
        0 0 16px rgba(255,105,180,0.9);
    }

    h3.miniTitle {
      margin: 12px 0 6px;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .episodeRow {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      margin-bottom: 4px;
      background: transparent;
      border-radius: 0;
      backdrop-filter: none;
      box-shadow: none;
      border-left: none;
    }

    .perfGroup {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 10px;
    }

    .episodeRow img {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid rgba(255, 105, 180, 0.9);
      box-shadow: 0 0 10px rgba(255,105,180,0.9);
      flex-shrink: 0;
    }
    .bigPerfList {
  display: flex;
  flex-direction: column;
  gap: 18px;
  margin-top: 8px;
}

.bigPerfCard {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  padding: 10px 0 4px;
}

.bigPerfCard img {
  width: 90px;
  height: 90px;
  border-radius: 50%;
  object-fit: cover;
  border: 3px solid #ff69b4;
  box-shadow: 0 0 14px rgba(255,105,180,0.9);
}

.bigPerfName {
  margin-top: 6px;
  font-size: 0.95rem;
  font-weight: 600;
}

.bigPerfText {
  font-size: 0.8rem;
  opacity: 0.9;
}

    .episodeText {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .episodeName {
      font-size: 0.95rem;
      font-weight: 600;
    }

    .episodePerf {
      font-size: 0.8rem;
      opacity: 0.9;
    }

    .perf-excellent   { border-left-color: #00ff9d; }
    .perf-good        { border-left-color: #5dd9ff; }
    .perf-bad         { border-left-color: #ffd54a; }
    .perf-awful       { border-left-color: #ff3b6b; }

    .perfGrid {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 14px 12px;
    }

    .perfCard {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      padding: 8px 8px 10px;
      border-radius: 18px;
      background: rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(10px);
      box-shadow: 0 0 14px rgba(0,0,0,0.7);
      max-width: 120px;
    }

    .perfCard img {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      object-fit: cover;
      border: 3px solid #ff69b4;
      box-shadow: 0 0 12px rgba(255,105,180,0.9);
      margin-bottom: 4px;
    }

    .perfCard.perf-excellent img {
      border-color: #00ff9d;
      box-shadow: 0 0 14px rgba(0,255,157,0.9);
    }

    .perfCard.perf-good img {
      border-color: #5dd9ff;
      box-shadow: 0 0 14px rgba(93,217,255,0.9);
    }

    .perfCard.perf-bad img {
      border-color: #ffd54a;
      box-shadow: 0 0 14px rgba(255,213,74,0.9);
    }

    .perfCard.perf-awful img {
      border-color: #ff3b6b;
      box-shadow: 0 0 14px rgba(255,59,107,0.9);
    }

    .winnerCard {
      text-align: center;
      padding-top: 10px;
    }

    .winnerCard img {
      width: 90px;
      height: 90px;
      border-radius: 50%;
      object-fit: cover;
      border: 4px solid #ffd700;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.9);
      margin-bottom: 10px;
    }

    .winnerTitle {
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      margin-bottom: 4px;
    }

    .runnerUpsWrapper {
  margin-top: 12px;
  text-align: center;
}

.runnerUpsTitle {
  font-size: 0.85rem;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  margin-bottom: 6px;
}

.runnerUpsGrid {
  display: flex;
  justify-content: center;
  gap: 14px;
}

.runnerUpCard {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.runnerUpCard img {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  object-fit: cover;
  border: 3px solid #ffd700;
  box-shadow: 0 0 12px rgba(255,215,0,0.8);
}

.runnerUpName {
  margin-top: 4px;
  font-size: 0.8rem;
}

    .lipSyncGrid {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 16px;
  margin-top: 10px;
}

.lipSyncRow {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  background: transparent;
  box-shadow: none;
  border-radius: 0;
  padding: 0;
}

.lipSyncRow img {
  width: 90px;
  height: 90px;
  border-radius: 50%;
  object-fit: cover;
  border: 3px solid #ff69b4;
  box-shadow: 0 0 14px rgba(255,105,180,0.9);
}
    /* ===== Doblaje interactivo ===== */

.lipBattleContainer {
  display: flex;
  justify-content: center;
  gap: 24px;
  margin-top: 16px;
}

.lipBattleCard {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  width: 110px;
  transition: transform 0.4s ease, filter 0.4s ease, opacity 0.4s ease,
              box-shadow 0.4s ease, border-color 0.4s ease;
}

.lipBattleCard img {
  width: 90px;
  height: 90px;
  border-radius: 50%;
  object-fit: cover;
  border: 4px solid #ff69b4;
  box-shadow: 0 0 18px rgba(255,105,180,0.9);
  margin-bottom: 6px;
}

.lipBattleCard .lipQueenName {
  font-size: 0.9rem;
  font-weight: 600;
}

/* Movimiento izquierda ‚Üî derecha durante el doblaje */
.lipBattleCard.battle-left {
  transform: translateX(-18px);
}

.lipBattleCard.battle-right {
  transform: translateX(18px);
}

/* Ganadora: viene al frente */
.lipBattleCard.winnerPulse {
  transform: scale(1.12);
  border-color: #ffd700;
  box-shadow: 0 0 22px rgba(255,215,0,1);
}

/* Perdedorx: blanco y negro al final */
.lipBattleCard.loserCard img {
  filter: grayscale(100%);
  opacity: 0.9;
}

/* Sale hacia la izquierda (ganadora salvada) */
@keyframes slideOutLeft {
  to {
    transform: translateX(-180%) scale(0.9);
    opacity: 0;
  }
}

/* Sale hacia la derecha (eliminada al dragaltar) */
@keyframes slideOutRight {
  to {
    transform: translateX(180%) scale(0.9);
    opacity: 0;
  }
}

.lipBattleCard.slideOutLeft {
  animation: slideOutLeft 0.8s forwards;
}

.lipBattleCard.slideOutRight {
  animation: slideOutRight 0.8s forwards;
}
    /* Contenedor del duelo */
.lipSyncDuel {
  display: flex;
  justify-content: center;
  gap: 40px;
  margin-top: 18px;
  transition: all 0.4s ease;
}

/* Cuando tenga esta clase, las queens intercambian posiciones */
.lipSyncDuel.swap {
  flex-direction: row-reverse; /* üëà invierte izquierda/derecha */
}

/* Cada queen del doblaje */
.lipDiva {
  display: flex;
  flex-direction: column;
  align-items: center;
  transition: transform 0.7s ease, opacity 0.7s ease, filter 0.7s ease;
}

.lipDiva img {
  width: 90px;
  height: 90px;
  border-radius: 50%;
  object-fit: cover;
  border: 4px solid #ff69b4;
  box-shadow: 0 0 18px rgba(255,105,180,0.9);
}

/* Estado final de la ganadora (m√°s grande y al frente) */
.lipWinnerFinal {
  transform: scale(1.25) translateY(-4px);
}

/* Estado final de la perdedora (BN, m√°s discreta) */
.lipLoserFinal {
  filter: grayscale(100%);
  opacity: 0.9;
}

/* Salidas lentas hacia los lados */
.lipExitLeft {
  transform: translateX(-130%) scale(0.9);
  opacity: 0;
}

.lipExitRight {
  transform: translateX(130%) scale(0.9);
  opacity: 0;
}

/* Mensaje bajo el duelo */
#lipMessage {
  margin-top: 16px;
  text-align: center;
  font-size: 0.9rem;
}
    .topBottomGrid {
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* 3 arriba, 3 abajo */
  gap: 16px 10px;
  margin-top: 10px;
}
    .finalistsGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr); /* 2 arriba, 2 abajo */
  gap: 16px 10px;
  margin-top: 10px;
  justify-items: center; /* para que queden centradas en cada columna */
}

.topBottomCard {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.topBottomCard img {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  object-fit: cover;
  border: 3px solid #ff69b4;
  box-shadow: 0 0 14px rgba(255,105,180,0.9);
}

.topBottomName {
  margin-top: 6px;
  font-size: 0.85rem;
  font-weight: 600;
}

    .eliminationWrapper {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-top: 6px;
    }

    .safeQueen, .outQueen {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }

    .safeQueen img {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      object-fit: cover;
      border: 4px solid #00ff9d;
      box-shadow: 0 0 18px rgba(0,255,157,0.9);
    }

    .outQueen img {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      object-fit: cover;
      border: 4px solid #ff0037;
      box-shadow: 0 0 18px rgba(255,0,55,0.9);
      filter: grayscale(100%);
    }

    .outLabel {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #ff8fa8;
    }
    .elimName {
  margin-top: 6px;
  font-size: 1rem;
  font-weight: 700;
  text-align: center;
  color: #ffffff;
  text-shadow:
    0 0 8px rgba(255, 20, 147, 0.9),
    0 0 16px rgba(255, 255, 255, 0.85);
}

.elimStatus {
  margin-top: 4px;
  font-size: 0.9rem;
  text-align: center;
  color: #ffe6ff;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  text-shadow:
    0 0 6px rgba(0, 0, 0, 0.9),
    0 0 14px rgba(255, 105, 180, 0.95);
}

.elimOutLabel {
  margin-top: 10px;
  font-size: 0.85rem;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  color: #ff8fa8;
  text-shadow:
    0 0 10px rgba(0, 0, 0, 0.9),
    0 0 18px rgba(255, 20, 147, 0.95);
}

    #nextBtn {
      font-size: 1.1em;
      padding: 12px 20px;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      background: linear-gradient(135deg, #ff37b3, #ff70d6);
      color: white;
      font-weight: bold;
      text-shadow: 0 0 8px rgba(255,255,255,0.8);
      box-shadow: 0 0 18px rgba(255, 20, 147, 0.85),
                  0 0 38px rgba(255, 20, 147, 0.6);
      transition: transform 0.18s ease, box-shadow 0.2s ease, opacity 0.2s;
      backdrop-filter: blur(6px);
      margin: 18px auto 0;
      display: block;
      width: 80%;
      max-width: 260px;
    }

    #nextBtn:hover {
      transform: scale(1.04);
      box-shadow: 0 0 28px rgba(255, 20, 147, 1),
                  0 0 60px rgba(255, 20, 147, 0.8);
    }

    #nextBtn:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    #episodeContent {
      margin-top: 4px;
    }
    .top-align {
  align-self: flex-start !important;
  margin-top: 20px !important;
}
    .savedQueensMessage {
  margin: 14px auto 10px;
  text-align: center;
  font-size: 1.05rem;
  max-width: 300px;
  line-height: 1.25;
  background: rgba(0,0,0,0.35);
  padding: 8px 12px;
  border-radius: 16px;
  backdrop-filter: blur(10px);
  box-shadow: 0 0 20px rgba(255, 20, 147, 0.6),
              0 0 35px rgba(255, 105, 180, 0.4);
  color: #ffd8ff;
  text-shadow: 0 0 6px rgba(255, 255, 255, 0.85),
               0 0 14px rgba(255, 105, 180, 0.9);
}

.savedQueensMessage strong {
  font-weight: 600;
  color: #fff;
}

.savedSubtitle {
  font-size: 0.85rem;
  opacity: 0.9;
  margin-top: 4px;
}
    /* ===== TRACK RECORD ESTILO TABLA ===== */

.trackTable {
  margin-top: 10px;
  padding: 10px 8px 12px;
  border-radius: 18px;
  background: rgba(255, 255, 255, 0.92);  /* üëà blanco/glass */
  backdrop-filter: blur(10px);
  box-shadow: 0 0 22px rgba(0,0,0,0.45);
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.trackRow {
  display: grid;
  align-items: center;
  column-gap: 4px;
}

.trackCell {
  font-size: 0.75rem;
  text-align: center;
}

/* Columna de nombre + foto */
.trackNameCell {
  display: flex;
  align-items: center;
  gap: 6px;
  text-align: left;
}

.trackNameCell img {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  object-fit: cover;
  border: 2px solid #ff69b4;
  box-shadow: 0 0 8px rgba(255,105,180,0.8);
}

.trackNameCell span {
  font-size: 0.8rem;
}

/* Encabezados */
.trackHeaderRow .trackCell {
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.08em;
}

.trackNameHeader {
  text-align: left;
}

.trackEpisodeHeader {
  font-size: 0.7rem;
}

/* Celdas de mark */
.trackMarkCell {
  padding: 4px 2px;
  border-radius: 6px;
  font-weight: 600;
  text-transform: uppercase;
}

/* Colores tipo La M√°s Draga */
.cell-win {
  background: #36c26b;
}

.cell-high {
  background: #7bdcff;
}

.cell-low {
  background: #ffd86b;
}

.cell-bottom {
  background: #ff4b6e;
}

.cell-safe {
  background: #b4b4b4;
}

.cell-blank {
  background: rgba(0,0,0,0.25);
  opacity: 0.7;
}
 /* a√±adir */
.cell-return {
  background: #9b59ff; /* morado - ajusta si quieres otro */
  color: #fff;
}   
    
    /* üåà Texto glam general */
body, .episodeName, .savedQueensMessage, .safeText, .sectionTitle {
  font-family: 'Poppins', 'Montserrat', sans-serif;
  font-weight: 600;
}

/* üí´ Estilo texto blanco */
p, span, .episodePerf, .challengeText, #episodeSubtitle {
  color: #ffffff;
  text-shadow: 
    0 0 8px rgba(255, 20, 147, 0.9),
    0 0 14px rgba(255, 255, 255, 0.6);
}
    .glowText {
  animation: neonGlitter 2.5s infinite alternate ease-in-out;
}

@keyframes neonGlitter {
  0% { text-shadow: 0 0 6px #ff52d9; }
  100% { text-shadow: 0 0 18px #ffd1ff; }
}
    
    .winnerTitle {
  color: #ffe88a !important;
  text-shadow:
    0 0 10px #ffdd55,
    0 0 20px #ffb800,
    0 0 35px #ff9f00;
  animation: goldPulse 2.2s infinite ease-in-out;
}

@keyframes goldPulse {
  0% { opacity: 0.9; filter: brightness(1.1); }
  100% { opacity: 1; filter: brightness(1.35); }
}
    /* T√≠tulo glam para LAS MENOS DEL RETO SON: */
.lipTitle {
  margin: 12px 0 10px;
  text-align: center;
  font-size: 1.1rem;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  background: linear-gradient(90deg, #ffdd55, #ff6bd5, #55e0ff);
  -webkit-background-clip: text;
  color: transparent;
  text-shadow:
    0 0 10px rgba(0, 0, 0, 0.9),
    0 0 18px rgba(255, 105, 180, 0.9);
}
    /* Nombre en el paso de doblaje */
.lipQueenName {
  margin-top: 6px;
  font-size: 0.95rem;
  font-weight: 600;
  text-align: center;
}

/* Texto tipo "Doblaje de eliminaci√≥n" / "Est√° salvada" */
.lipStatus {
  margin-top: 2px;
  font-size: 0.85rem;
  text-align: center;
  color: #ffe6ff;
  font-weight: 500;
  text-shadow:
    0 0 6px rgba(255, 20, 147, 0.9),
    0 0 12px rgba(255, 255, 255, 0.7);
}
    .lipTitle {
  margin: 12px 0 10px;
  text-align: center;
  font-size: 1.1rem;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  background: linear-gradient(90deg, #ffdd55, #ff6bd5, #55e0ff);
  -webkit-background-clip: text;
  color: transparent;
  text-shadow: 0 0 12px rgba(0,0,0,0.9);
}

.lipCard {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
}

.lipCard img {
  width: 90px;
  height: 90px;
  border-radius: 50%;
  object-fit: cover;
  border: 4px solid #ff69b4;
  box-shadow: 0 0 18px rgba(255,105,180,0.9);
}

.lipQueenName {
  font-size: 0.95rem;
  font-weight: 600;
  text-align: center;
}

.lipStatus {
  font-size: 0.85rem;
  font-weight: 500;
  text-align: center;
  margin-top: -3px;
  color: #ffe6ff;
  text-shadow: 
    0 0 6px rgba(255, 20, 147, 0.9),
    0 0 12px rgba(255, 255, 255, 0.7);
}
    .badge-elim {
  background: #444;        /* gris oscuro tipo l√°pida üíÄ */
  color: #ffffff;
  box-shadow: 0 0 12px rgba(0,0,0,0.7);
}
    .finalLipGrid {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 16px;
  margin-top: 18px;
}

.finalLipCard {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  text-align: center;
}

.finalLipCard img {
  width: 90px;
  height: 90px;
  border-radius: 50%;
  object-fit: cover;
  border: 4px solid #ff69b4;
  box-shadow: 0 0 18px rgba(255,105,180,0.9);
}

.finalLipCard.finalWinner img {
  border-color: #ffd700;
  box-shadow: 0 0 20px rgba(255,215,0,0.95);
}
    /* Panel de retorno abajo */
.comebackPanel {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 14px 16px 20px;
  background: rgba(0,0,0,0.9);
  backdrop-filter: blur(16px);
  box-shadow: 0 -8px 30px rgba(0,0,0,0.8);
  border-radius: 24px 24px 0 0;
  display: none;
  z-index: 999;
}

.comebackTitle {
  text-align: center;
  font-size: 0.95rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 8px;
}

.comebackList {
  display: flex;
  flex-wrap: nowrap;
  overflow-x: auto;
  gap: 10px;
  padding-bottom: 6px;
  margin-bottom: 10px;
}

.comebackCard {
  flex: 0 0 auto;
  width: 80px;
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  opacity: 0.75;
  transition: transform 0.15s, opacity 0.15s;
}

.comebackCard img {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  object-fit: cover;
  border: 3px solid #ff69b4;
  box-shadow: 0 0 14px rgba(255,105,180,0.8);
  margin-bottom: 4px;
}

.comebackCard span {
  font-size: 0.75rem;
  text-align: center;
}

.comebackCard.selected {
  opacity: 1;
  transform: translateY(-3px) scale(1.05);
}

#comebackConfirmBtn {
  width: 100%;
  border: none;
  border-radius: 999px;
  padding: 10px 16px;
  font-size: 0.95rem;
  font-weight: 700;
  background: linear-gradient(135deg,#ff37b3,#ff70d6);
  color:#fff;
  box-shadow: 0 0 18px rgba(255,20,147,0.9);
  cursor:pointer;
}

#comebackConfirmBtn:disabled {
  opacity: 0.5;
  box-shadow:none;
  cursor: default;
}

/* Final: selecci√≥n de ganadora manual */
.finalistSelectable {
  cursor: pointer;
  transition: transform 0.15s;
}

.finalistSelectable.selected img {
  border: 4px solid #ffd700;
  box-shadow: 0 0 20px rgba(255,215,0,0.95);
}

.finalistSelectable.selected .topBottomName {
  color:#ffe88a;
}
 
  </style>
</head>
<body>
  <div class="sim-panel">
    <h1 id="episodeTitle"></h1>
    <p id="episodeSubtitle"></p>

    <div id="episodeContent"></div>

    <button id="nextBtn">La m√°s‚Ä¶</button>
  </div>
    <!-- Panel de retorno -->
  <div id="comebackPanel" class="comebackPanel">
    <div class="comebackTitle">¬øQui√©n regresa a la competencia?</div>
    <div id="comebackList" class="comebackList"></div>
    <button id="comebackConfirmBtn" disabled>Confirmar regreso</button>
  </div>

  <script>
    
    // =========================
    //   RETOS POR TEMPORADA
    // =========================
    const challengesBySeason = {
      "1": ["La m√°s diva","La m√°s quincea√±era","La m√°s Thal√≠a","La m√°s Alebrije","La m√°s dram√°tica"],
      "2": ["La m√°s t√≠pica","La m√°s religiosa","La m√°s luchona","La m√°s pi√±ata","La m√°s Juanga","La m√°s independiente","La m√°s villana"],
      "3": ["La m√°s suertuda","La m√°s prehisp√°nica","La m√°s fichera","La m√°s Chespirito","La m√°s famosa","La m√°s legendaria","La m√°s bella se√±orita M√©xico","La m√°s buchona","La m√°s antojable"],
      "4": ["La m√°s folcl√≥rica","La m√°s pintada","La m√°s revolucionaria","La m√°s mezclilla","La m√°s cachuda","La m√°s famosa","La m√°s rosa mexicano","La m√°s chola","La m√°s Cri Cri","La m√°s imperial"],
      "5": ["La m√°s artesanal","La m√°s a color","La m√°s juguete","La m√°s famosa","La m√°s del Toro","La m√°s tejocote","La m√°s futurista","La m√°s Lele","La m√°s monja coronada"],
      "6": ["La m√°s monumental","La m√°s Frida","La m√°s Pixar","La m√°s recursiva","La m√°s floral","La m√°s nahual","La m√°s azul peltre","La m√°s animada","La m√°s divina Infantita","La m√°s galardonada"],
      "7": ["La m√°s Guelaguetza","La m√°s Silvia Pinal","La m√°s dulce","La m√°s recursiva","La m√°s metrera","La m√°s plicop√∫rpura","La m√°s panzuda","La m√°s ma√≠z","La m√°s Lupita"]
    };

    const specialChallenges = {
      reunion: "D√≠a de Muertas",
    };

    const allChallenges = [];
    for (const season in challengesBySeason) {
      challengesBySeason[season].forEach((name, index) => {
        allChallenges.push({
          id: `T${season}-${index + 1}`,
          name,
          season
        });
      });
    }
    allChallenges.push(
      { id: "SPECIAL-reunion", name: specialChallenges.reunion, season: "all", type: "reunion" },
    );

    const usedChallengeIds = [];

    function getRandomChallenge() {
      const disponibles = allChallenges.filter(ch => !usedChallengeIds.includes(ch.id));
      if (!disponibles.length) return null;
      const randomIndex = Math.floor(Math.random() * disponibles.length);
      const reto = disponibles[randomIndex];
      usedChallengeIds.push(reto.id);
      return reto;
    }

    // =========================
    //   DATOS DEL CAST
    // =========================
    const cast   = JSON.parse(localStorage.getItem("lmd_selectedQueens") || "[]");
    const config = JSON.parse(localStorage.getItem("lmd_seasonConfig") || "{}");

    // =========================
//   OPCIONES DE TEMPORADA
// =========================

// tipo de temporada: "regular" o "solo_las_mas"
const seasonType = config.seasonType || "regular";

// retorno: "none" (sin retorno) o "one_return" (un regreso)
const returnMode = config.returnMode || "none";

// n√∫mero de finalistas: 4, 3, 2, etc.
const finalistsNum = config.finalistsNum || 4;

// coronaci√≥n: "aleatorio", "decidir", "lipSync" (desde la pantalla 1)
const rawCrownMode = config.crownMode || "aleatorio";

// Lo mapeamos a claves internas m√°s sencillas
let crownMode;
switch (rawCrownMode) {
  case "aleatorio":
    crownMode = "random";
    break;
  case "decidir":
    crownMode = "user";
    break;
  case "lipSync":
    crownMode = "lipsync";
    break;
  default:
    crownMode = "random";
}

// para manejar retornos
let eliminatedQueens = [];

    let aliveQueens = cast.slice();
    const trackRecord = {};
    let episodeNumber = 1;

    const episodeTitleEl    = document.getElementById("episodeTitle");
    const episodeSubtitleEl = document.getElementById("episodeSubtitle");
    const episodeContentEl  = document.getElementById("episodeContent");
    const nextBtn           = document.getElementById("nextBtn");
// Panel de retorno
const comebackPanel      = document.getElementById("comebackPanel");
const comebackListEl     = document.getElementById("comebackList");
const comebackConfirmBtn = document.getElementById("comebackConfirmBtn");
let selectedComebackQueen = null;

// Final manual
let selectedFinalWinner = null;
    if (!cast.length) {
      episodeTitleEl.textContent = "No hay cast cargado";
      episodeSubtitleEl.textContent = "Vuelve a la pantalla inicial y selecciona tus femininosas ‚ú®";
      episodeContentEl.textContent = "";
      nextBtn.disabled = true;
    }
    let finaleBracket = null; // datos de los 3 doblajes de la final

    const performanceLabels = {
      excellent: "tuvo un excelente desempe√±o",
      good:      "tuvo un buen desempe√±o",
      bad:       "tuvo un mal desempe√±o",
      awful:     "tuvo un p√©simo desempe√±o"
    };

    let currentEpisode = null;
// -1 -> suspense ...
let step = -1;
let hasShownPerformance = false; // controla si ya mostramos el desempe√±o
    // üî• Variables para animaci√≥n del doblaje interactivo
let lipResultShown = false;
let lipSwapInterval = null;

// üëá solo estas dos, sin repetir eliminatedQueens
let comebackDone = false;
let comebackEpisode = null;

// üåÄ Elegimos en qu√© episodio puede pasar el retorno (si lo hay)
(function prepararRetorno() {
  if (returnMode === "none") return;

  const total = cast.length;   // üëà AQU√ç CAMBIAMOS storedQueens por cast
  const minEpisode = 2;
  const maxEpisodeBeforeTop5 = Math.max(minEpisode, total - 5);

  if (maxEpisodeBeforeTop5 < minEpisode) return;

  // Un episodio aleatorio entre 2 y antes de que queden 5
  comebackEpisode =
    Math.floor(Math.random() * (maxEpisodeBeforeTop5 - minEpisode + 1)) +
    minEpisode;
})();

    // =========================
//   PANEL DE RETORNO
// =========================
function openComebackPanel() {
  if (!eliminatedQueens.length) return;

  selectedComebackQueen = null;
  comebackConfirmBtn.disabled = true;
  comebackListEl.innerHTML = "";

  eliminatedQueens.forEach(q => {
    const card = document.createElement("div");
    card.className = "comebackCard";
    card.innerHTML = `
      <img src="${q.image}" alt="${q.name}">
      <span>${q.name}</span>
    `;
    card.addEventListener("click", () => {
      document
        .querySelectorAll(".comebackCard")
        .forEach(c => c.classList.remove("selected"));

      card.classList.add("selected");
      selectedComebackQueen = q;
      comebackConfirmBtn.disabled = false;
    });

    comebackListEl.appendChild(card);
  });

  comebackPanel.style.display = "block";
  nextBtn.disabled = true; // mientras decides, el bot√≥n principal se bloquea
}

// Cuando pulsas "Confirmar regreso"
comebackConfirmBtn.addEventListener("click", () => {
  if (!selectedComebackQueen) return;

  const index = eliminatedQueens.findIndex(
    q => q.name === selectedComebackQueen.name
  );
  if (index !== -1) {
    const returning = eliminatedQueens.splice(index, 1)[0];
    aliveQueens.push(returning);
    alert(`‚ú® ${returning.name} regresa a la competencia`);
  }

  comebackPanel.style.display = "none";
  nextBtn.disabled = false;

  // Despu√©s del retorno, arrancamos el siguiente episodio
  startNextEpisodeAfterTrack();
});
    
    // =========================
//   SAL√ìN DE LA FAMA
// =========================
function saveWinnerToHallOfFame(winner) {
  if (!winner) return;

  const KEY = "lmd_hallOfFame";
  const raw  = localStorage.getItem(KEY) || "[]";

  let list;
  try {
    list = JSON.parse(raw);
    if (!Array.isArray(list)) list = [];
  } catch(e) {
    list = [];
  }

  const entry = {
    name: winner.name,
    image: winner.image,
    seasonType,   // de tu config
    crownMode,    // random / lipsync / user
    date: new Date().toISOString()
  };

  list.push(entry);

  // Solo conservamos las √öLTIMAS 10
  const lastTen = list.slice(-10);
  localStorage.setItem(KEY, JSON.stringify(lastTen));
}

    // =========================
    //   CONSTRUIR EPISODIO
    // =========================
    function buildEpisode() {
      const challenge = getRandomChallenge() || { id: "fallback", name: "La Gran Final" };

      const shuffled = aliveQueens.slice().sort(() => Math.random() - 0.5);
      const n = shuffled.length;
      if (n === 0) return;

      const indexes = [...Array(n).keys()];

      function drawIndex() {
        const pos = Math.floor(Math.random() * indexes.length);
        return indexes.splice(pos, 1)[0];
      }

      const winnerIdx = drawIndex();

      const topIdxs = [];
      if (n >= 4) topIdxs.push(drawIndex());
      if (n >= 5) topIdxs.push(drawIndex());

      const lipIdxs = [];
      if (n >= 3) lipIdxs.push(drawIndex());
      if (n >= 4) lipIdxs.push(drawIndex());

      let extraBottomIdx = null;
      if (n >= 6 && indexes.length > 0) {
        extraBottomIdx = drawIndex();
      }

      // Seguridad: que la ganadora no sea parte de los lipIdxs (por si algo fuera raro)
if (lipIdxs.includes(winnerIdx)) {
  const remaining = indexes.slice(); 
  if (remaining.length > 0) {
    const newPos = Math.floor(Math.random() * remaining.length);
    winnerIdx = remaining[newPos];
  }
}

            // Solo habr√° una "La casi -": la tercera peor (extraBottomIdx)
      const lowIdxs = []; // ya no la usamos

      const performances = [];

            // ---------- NUEVO: construimos un mapa de marcas para ESTE episodio ----------
      // Inicializamos marksForEpisode con placeholder para todas las del cast
      const marksForEpisode = {};
      cast.forEach(cq => { marksForEpisode[cq.name] = ""; });

      // Asignar desempe√±o y marcas temporales usando shuffled
      for (let i = 0; i < n; i++) {
        const q = shuffled[i];
        let perfType = "good";
        let trackMark = "Salvada";

        if (i === winnerIdx) {
          perfType  = "excellent";
          trackMark = "La +";
        } else if (topIdxs.includes(i)) {
          perfType  = "good";
          trackMark = "La casi +";
        } else if (lipIdxs.includes(i)) {
          perfType  = "awful";
          trackMark = "La -";
        } else if (i === extraBottomIdx) {
          perfType  = "bad";
          trackMark = "La casi -";
        } else {
          perfType  = "good";
          trackMark = "Salvada";
        }

        performances.push({
          queen: q,
          type:  perfType,
          text:  performanceLabels[perfType],
          track: trackMark
        });

        // Guardamos la marca en el mapa (no hacemos push directo)
        marksForEpisode[q.name] = trackMark;
      }

      // Ahora empujamos la marca de ESTE episodio para TODAS las reinas del cast,
      // as√≠ mantenemos la longitud de los arrays sincronizada por columna (episodio).
      cast.forEach(cq => {
        if (!trackRecord[cq.name]) trackRecord[cq.name] = [];
        trackRecord[cq.name].push(marksForEpisode[cq.name] || "");
      });
          // DEBUG temporales (quita cuando confirmes que funciona)
      console.log("Episode", episodeNumber, "marksForEpisode:", marksForEpisode);
      console.log("Sample trackRecord (first 3):", Object.entries(trackRecord).slice(0,3));

      // Tops y bottoms
      const tops = [shuffled[winnerIdx], ...topIdxs.map(i => shuffled[i])];
      const bottoms = [...lipIdxs.map(i => shuffled[i])];
      if (extraBottomIdx !== null) bottoms.push(shuffled[extraBottomIdx]);

      // Pareja de lipsync
      const lipsyncPair = lipIdxs.map(i => shuffled[i]);
      let eliminated = null;
      let safeFromLipsync = null;

      if (lipsyncPair.length === 2) {
  const q1 = lipsyncPair[0];
  const q2 = lipsyncPair[1];

  const s1 = getTrackScore(q1.name);
  const s2 = getTrackScore(q2.name);

  if (s1 === s2) {
    // Si est√°n empatadas, que decida el destino üíÖ
    eliminated = Math.random() < 0.5 ? q1 : q2;
  } else if (s1 < s2) {
    // Menos puntos de temporada = se va
    eliminated = q1;
  } else {
    eliminated = q2;
  }

  safeFromLipsync = (eliminated === q1) ? q2 : q1;

} else if (lipsyncPair.length === 1) {
  // Caso raro: solo una en el lipsync
  eliminated = lipsyncPair[0];
  safeFromLipsync = null;
}

            currentEpisode = {
  challenge,
  performances,
  tops,
  bottoms,
  winner: shuffled[winnerIdx],
  lipsyncPair,
  eliminated,
  safeFromLipsync,
  episodeIndex: episodeNumber - 1 // <- guardamos el √≠ndice real del episodio
    };
   }

     // // ‚úÖ Ajustar el desempe√±o y el track record de la eliminada
// if (eliminated) {
//   // 1) Cambiar el chip de este episodio en la lista de performances
//   const perf = performances.find(p => p.queen.name === eliminated.name);
//   if (perf) {
//     perf.track = "Eliminada";
//   }
//
//   // 2) Cambiar la √öLTIMA casilla del track record a "Eliminada"
//   const marks = trackRecord[eliminated.name];
//   if (marks && marks.length > 0) {
//     marks[marks.length - 1] = "Eliminada";
//   }
// }

    // =========================
    //   RENDERS
    // =========================
    function renderPerformanceList() {
  episodeContentEl.innerHTML = "";

  const title = document.createElement("h2");
  title.className = "sectionTitle";
  title.textContent = "Desempe√±o del cast";
  episodeContentEl.appendChild(title);

  // Contenedor de todas las feminosas
  const list = document.createElement("div");
  list.className = "bigPerfList";

  currentEpisode.performances.forEach(item => {
    const card = document.createElement("div");
    card.className = `bigPerfCard perf-${item.type}`;

    card.innerHTML = `
      <img src="${item.queen.image}" alt="${item.queen.name}">
      <div class="bigPerfName">${item.queen.name}</div>
      <div class="bigPerfText">${item.text}</div>
    `;

    list.appendChild(card);
  });

  episodeContentEl.appendChild(list);
}

    function renderTopBottom() {
  episodeContentEl.innerHTML = "";
     

  // T√≠tulo general
  const title = document.createElement("h2");
  title.className = "sectionTitle";
  title.textContent = "Las m√°s y las menos";
  episodeContentEl.appendChild(title);

  const grid = document.createElement("div");
  grid.className = "topBottomGrid";

  // Juntamos tops y bottoms y los mezclamos para el drama
  const combined = [...currentEpisode.tops, ...currentEpisode.bottoms];

  // Quitamos duplicados por nombre (por si alguna est√° en ambos arrays)
  const seen = new Set();
  const unique = [];
  combined.forEach(q => {
    if (!seen.has(q.name)) {
      seen.add(q.name);
      unique.push(q);
    }
  });

  // Mezclar aleatoriamente
  unique.sort(() => Math.random() - 0.5);

  // Nos quedamos con m√°ximo 6
  const selected = unique.slice(0, Math.min(6, unique.length));

  selected.forEach(q => {
    const card = document.createElement("div");
    card.className = "topBottomCard";

    // Para el texto de debajo (mejores / peores) seg√∫n de d√≥nde venga
    const isTop = currentEpisode.tops.some(t => t.name === q.name);
    const isBottom = currentEpisode.bottoms.some(b => b.name === q.name);

    let tag = "";
    if (isTop && isBottom) {
      tag = "Drama total del episodio";
    } else if (isTop) {
      tag = "Entre las mejores del episodio";
    } else if (isBottom) {
      tag = "Entre las peores del episodio";
    }

    card.innerHTML = `
  <img src="${q.image}" alt="${q.name}">
  <div class="topBottomName">${q.name}</div>
`;

    grid.appendChild(card);
  });

  episodeContentEl.appendChild(grid);

        // ‚û§ Mostrar salvadas con estilo glam ‚ú®
    const saved = currentEpisode.performances
    .filter(p => p.track === "Salvada")
    .map(p => p.queen);

  if (saved.length > 0) {
    const savedDiv = document.createElement("div");
    savedDiv.className = "savedQueensMessage";

    const names = saved.map(q => q.name).join(" ¬∑ ");

    savedDiv.innerHTML = `
      <p><strong>${names}</strong></p>
      <p class="savedSubtitle">est√°n salvadas</p>
    `;
    
    episodeContentEl.appendChild(savedDiv);
  }
}

    function renderWinner() {
  episodeContentEl.innerHTML = "";

  const retoNombre = currentEpisode.challenge.name;
  let clean = retoNombre.replace(/^La m√°s\s*/i, "");
  if (!clean) clean = retoNombre;

  // T√≠tulo grande arriba con "es:"
  episodeTitleEl.textContent = `La m√°s ${clean} es:`;
  episodeSubtitleEl.textContent = "";

  // Tarjeta de la ganadora del episodio
  const card = document.createElement("div");
  card.className = "winnerCard";

  card.innerHTML = `
    <img src="${currentEpisode.winner.image}" alt="${currentEpisode.winner.name}">
    <div class="episodeName">${currentEpisode.winner.name}</div>
  `; // üëà sin (T2)

  episodeContentEl.appendChild(card);

  // ===== Casi la m√°s (top 2 sin la ganadora) =====
  const runnerUps = currentEpisode.tops
    .filter(q => q.name !== currentEpisode.winner.name)
    .slice(0, 2); // solo dos

  if (runnerUps.length > 0) {
    const wrap = document.createElement("div");
    wrap.className = "runnerUpsWrapper";

    const title = document.createElement("div");
    title.className = "runnerUpsTitle";
    title.textContent = "Casi la m√°s‚Ä¶";
    wrap.appendChild(title);

    const grid = document.createElement("div");
    grid.className = "runnerUpsGrid";

    runnerUps.forEach(q => {
      const c = document.createElement("div");
      c.className = "runnerUpCard";
      c.innerHTML = `
        <img src="${q.image}" alt="${q.name}">
        <div class="runnerUpName">${q.name}</div>
      `;
      grid.appendChild(c);
    });

    wrap.appendChild(grid);
    episodeContentEl.appendChild(wrap);
  }
}

    function renderLipsync() {
  episodeContentEl.innerHTML = "";

  const retoNombre = currentEpisode.challenge.name;
  episodeTitleEl.textContent = retoNombre;
  episodeSubtitleEl.textContent = "Doblaje de eliminaci√≥n";

  const winner = currentEpisode.safeFromLipsync;   // la que se salva
  const loser  = currentEpisode.eliminated;        // la que se va

  if (!winner || !loser) {
    episodeContentEl.innerHTML = "<p>Error en el doblaje üòÖ</p>";
    return;
  }

  lipResultShown = false;
  if (lipSwapInterval) {
    clearInterval(lipSwapInterval);
    lipSwapInterval = null;
  }

  // Contenedor del duelo
  const duel = document.createElement("div");
  duel.className = "lipSyncDuel";

  const left = document.createElement("div");
  left.className = "lipDiva";
  left.dataset.name = winner.name; // orden inicial da igual
  left.innerHTML = `
    <img src="${winner.image}" alt="${winner.name}">
    <div class="lipQueenName">${winner.name}</div>
  `;

  const right = document.createElement("div");
  right.className = "lipDiva";
  right.dataset.name = loser.name;
  right.innerHTML = `
    <img src="${loser.image}" alt="${loser.name}">
    <div class="lipQueenName">${loser.name}</div>
  `;

  duel.appendChild(left);
  duel.appendChild(right);
  episodeContentEl.appendChild(duel);

  // Mensaje bajo el duelo
  const msg = document.createElement("p");
  msg.id = "lipMessage";
  msg.textContent = "El destino se decide en el escenario‚Ä¶";
  episodeContentEl.appendChild(msg);

  // Configuramos el bot√≥n
  nextBtn.textContent = "Resultado del doblaje";
  nextBtn.disabled = true; // se habilita al final de la animaci√≥n

  // Arrancamos la animaci√≥n
  startLipSyncAnimation(duel, winner, loser, msg);
}
    function startLipSyncAnimation(duel, winner, loser, msgEl) {
  const durationMs = 10000; // 10 segundos aprox
  const stepMs = 800;       // cada cu√°nto se intercambian
  let elapsed = 0;

  lipSwapInterval = setInterval(() => {
    duel.classList.toggle("swap"); // üëà intercambia izquierda/derecha
    elapsed += stepMs;

    if (elapsed >= durationMs) {
      clearInterval(lipSwapInterval);
      lipSwapInterval = null;
      showLipSyncResult(duel, winner, loser, msgEl);
    }
  }, stepMs);
}

function showLipSyncResult(duel, winner, loser, msgEl) {
  lipResultShown = true;

  const cards = duel.querySelectorAll(".lipDiva");
  let winnerCard = null;
  let loserCard  = null;

  cards.forEach(c => {
    if (c.dataset.name === winner.name) {
      winnerCard = c;
    } else {
      loserCard = c;
    }
  });

  // centramos ambas
  duel.classList.remove("swap");
  duel.style.justifyContent = "center";
  duel.style.gap = "20px";

  // estado visual final
  winnerCard.classList.add("lipWinnerFinal");
  loserCard.classList.add("lipLoserFinal");

  // mensaje: qui√©n se salva
  msgEl.textContent = `${winner.name}, est√°s salvada ‚ú®`;

  // Desplazamos primero a la ganadora, luego a la eliminada
  setTimeout(() => {
    winnerCard.classList.add("lipExitLeft");

    setTimeout(() => {
      msgEl.textContent = `${loser.name}, ahora vas al Dragaltar‚Ä¶ üíê`;
      loserCard.classList.add("lipExitRight");

       // üëâ aqu√≠ hacemos la eliminaci√≥n REAL en los datos (solo UNA vez)
const elim = currentEpisode.eliminated;
if (elim) {
  // Guardar en eliminadas y quitar de la lista activa
  eliminatedQueens.push(elim);
  aliveQueens = aliveQueens.filter(q => q.name !== elim.name);

  // Actualizar el performance del episodio
  const perf = currentEpisode.performances.find(p => p.queen.name === elim.name);
  if (perf) perf.track = "Eliminada";

  // ‚≠ê Usamos el √≠ndice capturado en buildEpisode()
  const idx = currentEpisode && typeof currentEpisode.episodeIndex === 'number'
    ? currentEpisode.episodeIndex
    : Math.max(0, episodeNumber - 1);

  // Asegurar longitud del track record
  if (!trackRecord[elim.name]) trackRecord[elim.name] = [];
  while (trackRecord[elim.name].length <= idx) {
    trackRecord[elim.name].push("");
  }

  // Marcar eliminaci√≥n en la columna correcta
  trackRecord[elim.name][idx] = "Eliminada";
}

      // Activamos el bot√≥n para ir directo al Track record
      nextBtn.textContent = "Track record";
      nextBtn.disabled = false;
    }, 1500); // tiempo para que la ganadora salga
  }, 1500);   // tiempo para que se quede un momento en el centro
}

    function renderTrackRecord() {
  episodeContentEl.innerHTML = "";

  const title = document.createElement("h2");
  title.className = "sectionTitle";
  title.textContent = "Track record de la temporada";
  episodeContentEl.appendChild(title);

  const wrapper = document.createElement("div");
  wrapper.className = "trackTable";

  // misma definici√≥n de columnas para todas las filas
  const gridTemplate =
    `minmax(130px, 1.8fr) repeat(${episodeNumber}, minmax(44px, 1fr))`;

  // ===== Fila de encabezado =====
  const headerRow = document.createElement("div");
  headerRow.className = "trackRow trackHeaderRow";
  headerRow.style.gridTemplateColumns = gridTemplate;

  const nameHeader = document.createElement("div");
  nameHeader.className = "trackCell trackNameHeader";
  nameHeader.textContent = "Feminosa";
  headerRow.appendChild(nameHeader);

  for (let ep = 1; ep <= episodeNumber; ep++) {
    const hCell = document.createElement("div");
    hCell.className = "trackCell trackEpisodeHeader";
    hCell.textContent = `EP${ep}`;
    headerRow.appendChild(hCell);
  }

  wrapper.appendChild(headerRow);

  // ===== Ordenar filas: activas arriba, eliminadas abajo =====

// Primero las que siguen vivas, luego las eliminadas
const displayOrder = [...aliveQueens, ...eliminatedQueens];

// Evitar duplicados inesperados
const seenNames = new Set();
const uniqueDisplay = [];
displayOrder.forEach(q => {
  if (!seenNames.has(q.name)) {
    seenNames.add(q.name);
    uniqueDisplay.push(q);
  }
});

// Ahora iteramos sobre uniqueDisplay en vez de cast
uniqueDisplay.forEach(q => {
  const row = document.createElement("div");
  row.className = "trackRow";
  row.style.gridTemplateColumns = gridTemplate;

  const nameCell = document.createElement("div");
  nameCell.className = "trackCell trackNameCell";
  nameCell.innerHTML = `
    <img src="${q.image}" alt="${q.name}">
    <span>${q.name}</span>
  `;
  row.appendChild(nameCell);

  const marks = trackRecord[q.name] || [];

  for (let ep = 0; ep < episodeNumber; ep++) {
    const mark = marks[ep] || "";
    const cell = document.createElement("div");
    cell.className = "trackCell trackMarkCell " + getMarkClass(mark);
    cell.textContent = mark || "";
    row.appendChild(cell);
  }

  wrapper.appendChild(row);
});

  episodeContentEl.appendChild(wrapper);
}

// Mapea "La +" / "La casi +" etc a colores
function getMarkClass(mark) {
  switch (mark) {
    case "La +":      return "cell-win";
    case "La casi +": return "cell-high";
    case "La casi -": return "cell-low";
    case "La -":      return "cell-bottom";
    case "Salvada":   return "cell-safe";
    case "Eliminada": return "badge-elim";
    case "Retorno": return "cell-return";
    default:          return "cell-blank";
  }
}
// =========================
//   PUNTOS DE TRACK RECORD
// =========================
function getTrackScore(name) {
  const marks = trackRecord[name] || [];
  let score = 0;

  for (const m of marks) {
    switch (m) {
      case "La +":        // gan√≥ el reto
        score += 4;
        break;
      case "La casi +":   // top del reto
        score += 3;
        break;
      case "Salvada":     // safe
        score += 2;
        break;
      case "La casi -":   // casi en el fondo
        score += 1;
        break;
      case "La -":        // bottom / doblaje
        score += 0;
        break;
      case "Eliminada":   // por si vuelve en un retorno
        score -= 1;
        break;
      default:
        break;
    }
  }

  return score;
}
    // Elige la feminosa con mejor track record entre dos
function pickByTrackRecord(q1, q2) {
  const s1 = getTrackScore(q1.name);
  const s2 = getTrackScore(q2.name);

  // Si est√°n empatadas, desempate aleatorio
  if (s1 === s2) {
    return Math.random() < 0.5 ? q1 : q2;
  }

  // Se queda la que tenga mejor puntuaci√≥n
  return s1 > s2 ? q1 : q2;
}
    function prepareFinaleBracket() {
  const finalists = aliveQueens.slice();
  if (finalists.length < 4) return null;

  const shuffled = finalists.slice().sort(() => Math.random() - 0.5);
  const [a, b, c, d] = shuffled;

  const r1Winner1 = pickByTrackRecord(a, b);
  const r1Loser1  = r1Winner1 === a ? b : a;

  const r1Winner2 = pickByTrackRecord(c, d);
  const r1Loser2  = r1Winner2 === c ? d : c;

  const crownWinner = pickByTrackRecord(r1Winner1, r1Winner2);
  const finalLoser  = crownWinner === r1Winner1 ? r1Winner2 : r1Winner1;

  finaleBracket = {
    a, b, c, d,
    r1Winner1, r1Loser1,
    r1Winner2, r1Loser2,
    crownWinner, finalLoser
  };
}
  function startFinale(manualWinner) {
  const finalists = aliveQueens.slice();

  if (!finalists.length) {
    episodeTitleEl.textContent = "La Gran Final";
    episodeSubtitleEl.textContent = "No hay finalistas cargadas üòÖ";
    episodeContentEl.innerHTML = "";
    nextBtn.textContent = "Fin de la simulaci√≥n";
    nextBtn.disabled = false;
    return;
  }

  episodeTitleEl.textContent = "La Gran Final";
  episodeSubtitleEl.textContent = "Ganadora de la temporada";

  let winner = null;

  // üîπ MODO 3: T√ö DECIDES
  if (crownMode === "user") {
    if (manualWinner) {
      winner = manualWinner;
    } else {
      // Por si acaso se llama sin selecci√≥n
      winner = finalists[Math.floor(Math.random() * finalists.length)];
    }

    episodeContentEl.innerHTML = `
      <div class="winnerCard">
        <div class="winnerTitle">¬°La m√°s ganadora es‚Ä¶!</div>
        <img src="${winner.image}" alt="${winner.name}">
        <div class="episodeName">${winner.name}</div>
      </div>
    `;

  } else {
    // üîπ MODO ALEATORIO o LIPSYNC cuando NO son 4 finalistas
    if (crownMode === "lipsync") {
      // Elegimos por mejor track record entre todas las finalistas
      winner = finalists.reduce((best, q) => {
        if (!best) return q;
        return pickByTrackRecord(best, q);
      }, null);
    } else {
      // Modo aleatorio puro
      winner = finalists[Math.floor(Math.random() * finalists.length)];
    }

    episodeContentEl.innerHTML = `
      <div class="winnerCard">
        <div class="winnerTitle">¬°La m√°s ganadora es‚Ä¶!</div>
        <img src="${winner.image}" alt="${winner.name}">
        <div class="episodeName">${winner.name}</div>
      </div>
    `;
  }

  // Guardar en Sal√≥n de la Fama
  if (winner) {
    saveWinnerToHallOfFame(winner);
  }

  nextBtn.textContent = "Fin de la simulaci√≥n";
  nextBtn.disabled = false;
}

      function renderFinalists() {
  episodeContentEl.innerHTML = "";

  const title = document.createElement("h2");
  title.className = "sectionTitle";
  title.textContent = "Finalistas de la temporada";
  episodeContentEl.appendChild(title);

  const grid = document.createElement("div");
grid.className = "finalistsGrid"; // 2 x 2 solo en la final

  aliveQueens.forEach(q => {
    const card = document.createElement("div");
    card.className = "topBottomCard";

    card.innerHTML = `
      <img src="${q.image}" alt="${q.name}">
      <div class="topBottomName">${q.name}</div>
    `;

    // Si la coronaci√≥n es "T√∫ decides", las finalistas son clicables
    if (crownMode === "user") {
      card.classList.add("finalistSelectable");
      card.addEventListener("click", () => {
        document
          .querySelectorAll(".finalistSelectable")
          .forEach(c => c.classList.remove("selected"));

        card.classList.add("selected");
        selectedFinalWinner = q;
      });
    }

    grid.appendChild(card);
  });

  // üëâ aqu√≠ se a√±ade la grid al episodio
  episodeContentEl.appendChild(grid);
}

    function renderFinalLipRound1() {
  episodeContentEl.innerHTML = "";

  const title = document.createElement("h2");
  title.className = "sectionTitle";
  title.textContent = "Primer doblaje";
  episodeContentEl.appendChild(title);

  const grid = document.createElement("div");
  grid.className = "finalLipGrid";

  const { r1Winner1, r1Loser1 } = finaleBracket;

  const cardWin = document.createElement("div");
  cardWin.className = "finalLipCard finalWinner";
  cardWin.innerHTML = `
    <img src="${r1Winner1.image}" alt="${r1Winner1.name}">
    <div class="lipQueenName">${r1Winner1.name}</div>
    <div class="lipStatus">Gana el doblaje y avanza</div>
  `;

  const cardLose = document.createElement("div");
  cardLose.className = "finalLipCard";
  cardLose.innerHTML = `
    <img src="${r1Loser1.image}" alt="${r1Loser1.name}">
    <div class="lipQueenName">${r1Loser1.name}</div>
    <div class="lipStatus">Queda eliminada</div>
  `;

  grid.appendChild(cardWin);
  grid.appendChild(cardLose);
  episodeContentEl.appendChild(grid);
}

function renderFinalLipRound2() {
  episodeContentEl.innerHTML = "";

  const title = document.createElement("h2");
  title.className = "sectionTitle";
  title.textContent = "Segundo doblaje";
  episodeContentEl.appendChild(title);

  const grid = document.createElement("div");
  grid.className = "finalLipGrid";

  const { r1Winner2, r1Loser2 } = finaleBracket;

  const cardWin = document.createElement("div");
  cardWin.className = "finalLipCard finalWinner";
  cardWin.innerHTML = `
    <img src="${r1Winner2.image}" alt="${r1Winner2.name}">
    <div class="lipQueenName">${r1Winner2.name}</div>
    <div class="lipStatus">Gana el doblaje y avanza</div>
  `;

  const cardLose = document.createElement("div");
  cardLose.className = "finalLipCard";
  cardLose.innerHTML = `
    <img src="${r1Loser2.image}" alt="${r1Loser2.name}">
    <div class="lipQueenName">${r1Loser2.name}</div>
    <div class="lipStatus">Queda eliminada</div>
  `;

  grid.appendChild(cardWin);
  grid.appendChild(cardLose);
  episodeContentEl.appendChild(grid);
}

function renderFinalLipGrandFinal() {
  episodeContentEl.innerHTML = "";

  const { crownWinner, finalLoser } = finaleBracket;

  // Bloque grande de ganadora
  const winnerCard = document.createElement("div");
  winnerCard.className = "winnerCard";
  winnerCard.innerHTML = `
    <div class="winnerTitle">¬°La m√°s ganadora es‚Ä¶!</div>
    <img src="${crownWinner.image}" alt="${crownWinner.name}">
    <div class="episodeName">${crownWinner.name}</div>
  `;
  episodeContentEl.appendChild(winnerCard);

  // Doblaje final visual
  const grid = document.createElement("div");
  grid.className = "finalLipGrid";

  const winCard = document.createElement("div");
  winCard.className = "finalLipCard finalWinner";
  winCard.innerHTML = `
    <img src="${crownWinner.image}" alt="${crownWinner.name}">
    <div class="lipQueenName">${crownWinner.name}</div>
    <div class="lipStatus">Se corona como La M√°s</div>
  `;

  const loseCard = document.createElement("div");
  loseCard.className = "finalLipCard";
  loseCard.innerHTML = `
    <img src="${finalLoser.image}" alt="${finalLoser.name}">
    <div class="lipQueenName">${finalLoser.name}</div>
    <div class="lipStatus">Queda como finalista</div>
  `;

  grid.appendChild(winCard);
  grid.appendChild(loseCard);
  episodeContentEl.appendChild(grid);

  // Guardamos en el Sal√≥n de la Fama aqu√≠
  saveWinnerToHallOfFame(crownWinner);
}
   // =========================
//   CONTROL DE PASOS
// =========================
function renderStep() {
  // Pantalla inicial de suspense NO necesita currentEpisode
  if (step === -1) {
    episodeTitleEl.textContent = "La m√°s‚Ä¶";
    episodeSubtitleEl.textContent = "Pulsa para revelar el reto del episodio";
    nextBtn.textContent = "Revelar reto";
    episodeContentEl.innerHTML = "";
    return;
  }

  if (!currentEpisode) return;

  const retoNombre = currentEpisode.challenge.name;

  switch (step) {
    case 0:
      episodeTitleEl.textContent = retoNombre;

      if (!hasShownPerformance) {
        // PRIMERA VEZ EN EL PASO 0: mostrar solo el reto
        episodeSubtitleEl.textContent = "Reto del episodio";
        nextBtn.textContent = "Mostrar desempe√±o";

        episodeContentEl.innerHTML = `
          <p class="challengeText">Las feminos√°s se enfrentan al reto:</p>
          <p class="challengeText challengeName">${retoNombre}</p>
        `;
      } else {
        // SEGUNDA VEZ EN EL PASO 0: mostrar el desempe√±o
        episodeSubtitleEl.textContent = "Desempe√±o del episodio";
        nextBtn.textContent = "Las m√°s y las menos";
        renderPerformanceList();

        document.querySelector(".sim-panel").classList.add("top-align");
      }
      break;

    case 1:
      episodeTitleEl.textContent = retoNombre;
      episodeSubtitleEl.textContent = "Las m√°s y las menos del reto";
      nextBtn.textContent = "Revelar a la m√°s‚Ä¶";
      renderTopBottom();
      break;

    case 2:
      nextBtn.textContent = "Ver las Menos";
      renderWinner();
      break;

        case 3:
  episodeTitleEl.textContent = retoNombre;
  episodeSubtitleEl.textContent = "";
  nextBtn.textContent = "Resultado del doblaje";

  document.querySelector(".sim-panel").classList.remove("top-align");
  renderLipsync(); // üëà usamos el sistema nuevo que intercambia posiciones
  break;

    case 5:
      episodeTitleEl.textContent = "Track record de la temporada";
      episodeSubtitleEl.textContent = "Resumen hasta este episodio";

      nextBtn.textContent =
        aliveQueens.length > finalistsNum
          ? "Siguiente episodio"
          : "Ir a la Gran Final";

      renderTrackRecord();
      break;

        case 6:
      episodeTitleEl.textContent = "La Gran Final";
      episodeSubtitleEl.textContent = "Finalistas de la temporada";

      if (crownMode === "lipsync") {
        nextBtn.textContent = "Doblaje por la corona";
      } else if (crownMode === "user") {
        nextBtn.textContent = "Toca la feminosa que quieres coronar";
      } else {
        nextBtn.textContent = "Coronar al azar";
      }

      renderFinalists();
      break;
         
    case 7:
      // Primer doblaje de la final (solo lipsync + 4 finalistas)
      if (crownMode === "lipsync" && finaleBracket) {
        episodeTitleEl.textContent = "La Gran Final";
        episodeSubtitleEl.textContent = "Primer doblaje";
        nextBtn.textContent = "Segundo doblaje";
        renderFinalLipRound1();
      }
      break;

    case 8:
      if (crownMode === "lipsync" && finaleBracket) {
        episodeTitleEl.textContent = "La Gran Final";
        episodeSubtitleEl.textContent = "Segundo doblaje";
        nextBtn.textContent = "Doblaje por la corona";
        renderFinalLipRound2();
      }
      break;

    case 9:
      if (crownMode === "lipsync" && finaleBracket) {
        episodeTitleEl.textContent = "La Gran Final";
        episodeSubtitleEl.textContent = "Doblaje por la corona";
        nextBtn.textContent = "Fin de la simulaci√≥n";
        renderFinalLipGrandFinal();
      }
      break;
  }
}
        
        function startNextEpisodeAfterTrack() {
  hasShownPerformance = false;
  episodeNumber++;
  buildEpisode();
  step = -1;
  renderStep();
}

// =========================
//   CLICK DEL BOT√ìN
// =========================
nextBtn.addEventListener("click", () => {
  if (!cast.length) return;
  if (nextBtn.disabled) return;

    // Fin de la simulaci√≥n ‚Üí volver al inicio
    if (step === 9 && nextBtn.textContent === "Fin de la simulaci√≥n") {
    window.location.href = "index.html";
    return;
  }

  // Primer click: construir episodio
  if (step === -1) {
    hasShownPerformance = false; // siempre empezar desde el reto
    buildEpisode();
    step = 0;
    renderStep();
    return;
  }

     // Despu√©s del track record
  if (step === 5) {
    if (aliveQueens.length > finalistsNum) {

      // üîÅ ¬øToca retorno en el PR√ìXIMO episodio?
      if (
        !comebackDone &&
        comebackEpisode &&
        eliminatedQueens.length &&
        episodeNumber + 1 === comebackEpisode &&
        returnMode !== "none"
      ) {
        comebackDone = true;

        // Modo retorno aleatorio / mega ‚Üí inmediato
        if (returnMode === "aleatorio" || returnMode === "mega") {
  const idx = Math.floor(Math.random() * eliminatedQueens.length);
  const returning = eliminatedQueens.splice(idx, 1)[0];
  aliveQueens.push(returning);

  // A) Marcar el retorno en el trackRecord (columna comebackEpisode - 1)
  if (!trackRecord[returning.name]) trackRecord[returning.name] = [];
  const ridx = comebackEpisode - 1;
  while (trackRecord[returning.name].length <= ridx) trackRecord[returning.name].push("");
  trackRecord[returning.name][ridx] = "Retorno";

  if (index !== -1) {
  const returning = eliminatedQueens.splice(index, 1)[0];
  aliveQueens.push(returning);

  // B) Marcar el retorno en el trackRecord (columna comebackEpisode - 1)
  if (!trackRecord[returning.name]) trackRecord[returning.name] = [];
  const ridx = comebackEpisode - 1;
  while (trackRecord[returning.name].length <= ridx) trackRecord[returning.name].push("");
  trackRecord[returning.name][ridx] = "Retorno";

  alert(`‚ú® ${returning.name} regresa a la competencia`);
  startNextEpisodeAfterTrack();
  return;
}

        // Modo "decide" ‚Üí abrimos panel glam abajo
        if (returnMode === "decide") {
          openComebackPanel();
          return; // esperamos a que pulses "Confirmar regreso"
        }
      }

      // Sin retorno en este episodio ‚Üí continuar normal
      startNextEpisodeAfterTrack();
      return;
    } else {
      // Ya estamos en las finalistas ‚Üí Gran final
      step = 6;
      renderStep();
      return;
    }

    // Gran final: ya vimos las finalistas, ahora coronamos
    // Gran final: ya vimos las finalistas
  if (step === 6) {
    // Modo "T√∫ decides"
    if (crownMode === "user") {
      if (!selectedFinalWinner) {
        alert("Toca la feminosa que quieres coronar antes de continuar ‚ú®");
        return;
      }
      startFinale(selectedFinalWinner);
      step = 9; // ya es pantalla final
      return;
    }

    // Modo lipsync con 4 finalistas ‚Üí 3 pantallas (doblaje 1, doblaje 2, final)
    if (crownMode === "lipsync" && aliveQueens.length === 4) {
      prepareFinaleBracket();   // calculamos los enfrentamientos
      step = 7;                 // primer doblaje
      renderStep();
      return;
    }

    // Otros casos (lipsync con 2 o 3 finalistas, o modo aleatorio)
    startFinale(null);
    step = 9; // pantalla final
    return;
  }

  // Flujo normal (0 ‚Üí 5)
  if (step >= 0 && step < 5) {
    // En el paso 0, primero mostramos SOLO el reto
    // y en el siguiente click mostramos el desempe√±o
    if (step === 0 && !hasShownPerformance) {
      hasShownPerformance = true;
      renderStep(); // actualiza la vista sin cambiar de paso
      return;
    }
      // Desde el paso del doblaje (3), si ya se mostr√≥ el resultado,
  // saltamos directamente al Track record (paso 5)
  if (step === 3 && lipResultShown) {
    step = 5;
    renderStep();
    return;
  }

    step++;
    renderStep();
  }
});

// Mostrar pantalla inicial
if (cast.length) {
  renderStep();
}
  </script>
</body>
</html>
